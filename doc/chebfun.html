
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>CHEBFUN :: CHEBFUN class for representing functions on [a,b].</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-01-30"><meta name="DC.source" content="chebfun_DOC.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>CHEBFUN :: CHEBFUN class for representing functions on [a,b].</h1><pre>  Class for approximating functions defined on finite, semi-infinite, or
  doubly-infinite intervals [a,b]. Functions may be smooth, piecewise smooth,
  weakly singular, or blow up on the interval.</pre><pre>CHEBFUN(F) constructs a CHEBFUN object representing the function F on the
interval [-1,1]. F may be a string, e.g., 'sin(x)', a function handle, e.g.,
@(x) x.^2 + 2*x + 1, or a vector of numbers. In the first two instances, F
should be "vectorized" in the sense that it may be evaluated at a column
vector of points x(:) in [-1,1] and return an output of size NxM where N =
length(x(:)). If this is not possible then the flag CHEBFUN(F, 'vectorize')
should be passed. CHEBFUN(F, 'vectorcheck', 'off') disables the automatic
checking for vector input. Additionally, F may be a CHEBFUN, in which case
CHEBFUN(F) is equivalent to CHEBFUN(@(X) FEVAL(F, X)). CHEBFUN() returns an
empty CHEBFUN object.</pre><pre>CHEBFUN(F, [A, B]) specifies an interval [A,B] on which the CHEBFUN is
defined, where A and/or B may be infinite. CHEBFUN(F, ENDS), where ENDS is a
1x(K+1) vector of unique ascending values, specifies a piecewise smooth
CHEBFUN defined on the interval [ENDS(1), ENDS(K+1)] with additional interior
breaks at ENDS(2), ..., ENDS(K). Specifying these breaks can be particularly
useful if F is known to have discontinuities. For example,
  CHEBFUN(@(x) abs(x), [-1, 0, 1]).
If a domain is passed to the constructor, it should always be the 2nd input.</pre><pre>CHEBFUN(A) or CHEBFUN(A, 'chebkind', 2), where A is an Nx1 matrix, constructs
a CHEBFUN object which interpolates the data in A on an N-point Chebyshev grid
of the second kind (see &gt;&gt; help chebpts). CHEBFUN(A, 'chebkind', 1) and
CHEBFUN(A, 'equi') are similar, but here the data is assumed to come from a
1st-kind Chebyshev or equispaced grid linspace(-1, 1, N), respectively. (In
the latter case, a smooth interpolant is constructed using an adaptive
Floater-Hormann scheme [Numer. Math. 107, 315-331 (2007)].). CHEBFUN(F, N) or
CHEBFUN(F, N, 'chebkind', 2) is equivalent to CHEBFUN(feval(F, chebpts(N)).</pre><pre>CHEBFUN({F1,...,Fk}, ENDS) constructs a piecewise smooth CHEBFUN which
represents Fj on the interval [ENDS(j), END(j+1)]. Each entry Fj may be a
string, function handle, or vector of doubles. For example
  CHEBFUN({@(x) sin(x), @(x) cos(x)}, [-1, 0, 1])</pre><pre>CHEBFUN(F, PREF) or CHEBFUN(F, [A, B], PREF) constructs a CHEBFUN object from
F with the options determined by the CHEBPREF object PREF. Construction time
options may also be passed directly to the constructor in the form CHEBFUN(F,
[A, B], PROP1, VAL1, PROP2, VAL2, ...). (See CHEBPREF for details of the
various preference options and their defaults.). In particular, CHEBFUN(F,
'splitting', 'on') allows the constructor to adaptively determine breakpoints
to better represent piecewise smooth functions F. For example,
  CHEBFUN(@(x) sign(x - .3), [-1, 1], 'splitting', 'on')
CHEBFUN(F, 'extrapolate', 'on') prevents the constructor from evaluating the
function F at the endpoints of the domain. Note that it is not possible to mix
PROP/VAL and PREF inputs in a single constructor call.</pre><pre>CHEBFUN(F, 'trunc', N) returns a smooth N-point CHEBFUN constructed by
computing the first N Chebyshev coefficients from their integral form, rather
than by interpolation at Chebyshev points.</pre><pre>CHEBFUN(F, ...), where F is an NxM matrix or an array-valued function handle,
returns an "array-valued" CHEBFUN. For example,
  CHEBFUN(rand(14, 2))
or
  CHEBFUN(@(x) [sin(x), cos(x)])
Note that each column in an array-valued CHEBFUN object is discretized in the
same way (i.e., the same breakpoint locations and the same underlying
representation). For more details see "&gt;&gt; help quasimatrix". Note the
difference between
  CHEBFUN(@(x) [sin(x), cos(x)], [-1, 0, 1])
and
  CHEBFUN({@(x) sin(x), @(x) cos(x)}, [-1, 0, 1]).
The former constructs an array-valued CHEBFUN with both columns defined on the
domain [-1, 0, 1]. The latter defines a single column CHEBFUN which represents
sin(x) in the interval [-1, 0) and cos(x) on the interval (0, 1].</pre><pre>See also CHEBPREF, CHEBPTS.</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% CHEBFUN :: CHEBFUN class for representing functions on [a,b].
% 
%    Class for approximating functions defined on finite, semi-infinite, or
%    doubly-infinite intervals [a,b]. Functions may be smooth, piecewise smooth,
%    weakly singular, or blow up on the interval.
% 
%  CHEBFUN(F) constructs a CHEBFUN object representing the function F on the
%  interval [-1,1]. F may be a string, e.g., 'sin(x)', a function handle, e.g.,
%  @(x) x.^2 + 2*x + 1, or a vector of numbers. In the first two instances, F
%  should be "vectorized" in the sense that it may be evaluated at a column
%  vector of points x(:) in [-1,1] and return an output of size NxM where N =
%  length(x(:)). If this is not possible then the flag CHEBFUN(F, 'vectorize')
%  should be passed. CHEBFUN(F, 'vectorcheck', 'off') disables the automatic
%  checking for vector input. Additionally, F may be a CHEBFUN, in which case
%  CHEBFUN(F) is equivalent to CHEBFUN(@(X) FEVAL(F, X)). CHEBFUN() returns an
%  empty CHEBFUN object.
% 
%  CHEBFUN(F, [A, B]) specifies an interval [A,B] on which the CHEBFUN is
%  defined, where A and/or B may be infinite. CHEBFUN(F, ENDS), where ENDS is a
%  1x(K+1) vector of unique ascending values, specifies a piecewise smooth
%  CHEBFUN defined on the interval [ENDS(1), ENDS(K+1)] with additional interior
%  breaks at ENDS(2), ..., ENDS(K). Specifying these breaks can be particularly
%  useful if F is known to have discontinuities. For example,
%    CHEBFUN(@(x) abs(x), [-1, 0, 1]).
%  If a domain is passed to the constructor, it should always be the 2nd input.
% 
%  CHEBFUN(A) or CHEBFUN(A, 'chebkind', 2), where A is an Nx1 matrix, constructs
%  a CHEBFUN object which interpolates the data in A on an N-point Chebyshev grid
%  of the second kind (see >> help chebpts). CHEBFUN(A, 'chebkind', 1) and
%  CHEBFUN(A, 'equi') are similar, but here the data is assumed to come from a
%  1st-kind Chebyshev or equispaced grid linspace(-1, 1, N), respectively. (In
%  the latter case, a smooth interpolant is constructed using an adaptive
%  Floater-Hormann scheme [Numer. Math. 107, 315-331 (2007)].). CHEBFUN(F, N) or
%  CHEBFUN(F, N, 'chebkind', 2) is equivalent to CHEBFUN(feval(F, chebpts(N)).
% 
%  CHEBFUN({F1,...,Fk}, ENDS) constructs a piecewise smooth CHEBFUN which
%  represents Fj on the interval [ENDS(j), END(j+1)]. Each entry Fj may be a
%  string, function handle, or vector of doubles. For example
%    CHEBFUN({@(x) sin(x), @(x) cos(x)}, [-1, 0, 1])
% 
%  CHEBFUN(F, PREF) or CHEBFUN(F, [A, B], PREF) constructs a CHEBFUN object from
%  F with the options determined by the CHEBPREF object PREF. Construction time
%  options may also be passed directly to the constructor in the form CHEBFUN(F,
%  [A, B], PROP1, VAL1, PROP2, VAL2, ...). (See CHEBPREF for details of the
%  various preference options and their defaults.). In particular, CHEBFUN(F,
%  'splitting', 'on') allows the constructor to adaptively determine breakpoints
%  to better represent piecewise smooth functions F. For example,
%    CHEBFUN(@(x) sign(x - .3), [-1, 1], 'splitting', 'on')
%  CHEBFUN(F, 'extrapolate', 'on') prevents the constructor from evaluating the
%  function F at the endpoints of the domain. Note that it is not possible to mix
%  PROP/VAL and PREF inputs in a single constructor call.
% 
%  CHEBFUN(F, 'trunc', N) returns a smooth N-point CHEBFUN constructed by
%  computing the first N Chebyshev coefficients from their integral form, rather
%  than by interpolation at Chebyshev points.
% 
%  CHEBFUN(F, ...), where F is an NxM matrix or an array-valued function handle,
%  returns an "array-valued" CHEBFUN. For example,
%    CHEBFUN(rand(14, 2))
%  or
%    CHEBFUN(@(x) [sin(x), cos(x)])
%  Note that each column in an array-valued CHEBFUN object is discretized in the
%  same way (i.e., the same breakpoint locations and the same underlying
%  representation). For more details see ">> help quasimatrix". Note the
%  difference between
%    CHEBFUN(@(x) [sin(x), cos(x)], [-1, 0, 1])
%  and
%    CHEBFUN({@(x) sin(x), @(x) cos(x)}, [-1, 0, 1]).
%  The former constructs an array-valued CHEBFUN with both columns defined on the
%  domain [-1, 0, 1]. The latter defines a single column CHEBFUN which represents
%  sin(x) in the interval [-1, 0) and cos(x) on the interval (0, 1]. 
% 
%  See also CHEBPREF, CHEBPTS.
%
##### SOURCE END #####
--></body></html>