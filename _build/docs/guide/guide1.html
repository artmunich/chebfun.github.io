<!DOCTYPE html>
<html>
  <head>
    <title>CHEBFUN GUIDE 1: GETTING STARTED WITH CHEBFUN &laquo; Chebfun</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <!-- Bootstrap -->
    <link href="/css/bootstrap-noprint.css" rel="stylesheet"><!--  media="screen" -->
    <link href="/css/site.css" rel="stylesheet"><!--  media="screen" -->
    <link href="/css/syntax.css" rel="stylesheet"><!--  media="screen" -->
    <link href="/css/tomorrow.css" rel="stylesheet"><!--  media="screen" -->
    <!-- <link href="/css/published.css" rel="stylesheet" media="screen"> -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<!-- ********* BEGIN GOOGLE ANALYTICS *********** -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4297200-9");
pageTracker._trackPageview();
} catch(err) {}</script>
<!-- ********* END GOOGLE ANALYTICS *********** -->  </head>

  <body>

    <!-- Fixed navbar -->
    <div id='navbar' class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">Chebfun</a>
        </div>
        <div class="navbar-collapse collapse">

          <!--<ul class="nav navbar-nav navbar-left"></ul>-->

          <ul class="nav navbar-nav navbar-right">
            <li><a href="/about/">About</a></li>
            <li><a href="/download/">Download</a></li>
            <li class="active"><a href="/docs/">Documentation</a></li>
            <li><a href="/examples/">Examples</a></li>
            <li><a href="/develop/">Develop</a></li>
            <li><a href="/citing/">Citing</a></li>
            <li><a href="/support/">Support</a></li>
          </ul>

        </div><!--/.nav-collapse -->
      </div>
    </div>


<div class="container">

    <ol class="breadcrumb">
       <li><a href="/">Home</a></li>
       <li><a href="/docs/">Documentation</a></li>
       <li><a href="/docs/guide/">The Chebfun Guide</a></li>
       <li class="active">CHEBFUN GUIDE 1: GETTING STARTED WITH CHEBFUN</li>
    </ol>

    <div class="page-header">
 
        <h1>CHEBFUN GUIDE 1: GETTING STARTED WITH CHEBFUN</h1>
        <h2>Lloyd N. Trefethen, October 2009, latest revision May 2014</h2>
    </div>

    <div class="row">

<!--
        <div class="col-md-4" role="navigation"> 
 
            <div id="sidebar" class="sidebar">
                <div class="">
                    <!- <a href="#"><strong>CHEBFUN GUIDE 1: GETTING STARTED WITH CHEBFUN</strong></a> ->
                    <div class="toc">
<ul>
<li><a href="#11-what-is-a-chebfun">1.1  What is a chebfun?</a></li>
<li><a href="#12-constructing-simple-chebfuns">1.2  Constructing simple chebfuns</a></li>
<li><a href="#13-operations-on-chebfuns">1.3  Operations on chebfuns</a></li>
<li><a href="#14-piecewise-smooth-chebfuns">1.4  Piecewise smooth chebfuns</a></li>
<li><a href="#15-infinite-intervals-and-infinite-function-values">1.5  Infinite intervals and infinite function values</a></li>
<li><a href="#16-rows-columns-and-quasimatrices">1.6  Rows, columns, and quasimatrices</a></li>
<li><a href="#17-how-this-guide-is-produced">1.7  How this Guide is produced</a></li>
<li><a href="#18-references">1.8  References</a></li>
</ul>
</div>

                    <hr/>
                </div>
            </div>
        </div>
-->

        <div class="content">
            <div class="col-md-8" data-spy="scroll" data-target="#sidenav" role="main">
                <h3 id="11-what-is-a-chebfun">1.1  What is a chebfun?</h3>
<p>A chebfun is a function of one variable defined on an interval $[a,b]$. The syntax for chebfuns is almost exactly the same as the usual Matlab syntax for vectors, with the familiar Matlab commands for vectors overloaded in natural ways. Thus, for example, whereas <code>sum(f)</code> returns the sum of the entries when <code>f</code> is a vector, it returns a definite integral when <code>f</code> is a chebfun.</p>
<p>Chebfun with a capital C is the name of the software system.</p>
<p>The aim of Chebfun is to "feel symbolic but run at the speed of numerics". More precisely our vision is to achieve for functions what floating-point arithmetic achieves for numbers: rapid computation in which each successive operation is carried out exactly apart from a rounding error that is very small in relative terms [Trefethen 2007].</p>
<p>The implementation of Chebfun is based on the mathematical fact that smooth functions can be represented very efficiently by polynomial interpolation in Chebyshev points, or equivalently, thanks to the Fast Fourier Transform, by expansions in Chebyshev polynomials.  For a simple function, 20 or 30 points often suffice, but the process is stable and effective even for functions complicated enough to require 1000 or 1,000,000 points. Chebfun makes use of adaptive procedures that aim to find the right number of points automatically so as to represent each function to roughly machine precision (about 15 digits of relative accuracy).  (Originally Chebfun stored function values at Chebyshev points; in Version 5 it switched to storing Chebyshev expansion coefficients.)</p>
<p>The mathematical foundations of Chebfun are for the most part well established by results scattered throughout the 20th century.  A key early figure, for example, was Bernstein in the 1910s. Much of the relevant material can be found collected in the Chebfun-based book [Trefethen 2013].</p>
<p>Chebfun was originally created by Zachary Battles and Nick Trefethen at Oxford during 2002-2005 [Battles &amp; Trefethen 2004].  Battles left the project in 2005, and soon four new members were added to the team: Ricardo Pachon (from 2006), Rodrigo Platte (from 2007), and Toby Driscoll and Nick Hale (from 2008). In 2009, Asgeir Birkisson and Mark Richardson also became involved, and other contributors included Pedro Gonnet, Joris Van Deun, and Georges Klein.  Nick Hale served as Director of the project during 2010-2014.  The Chebfun Version 5 rewrite was directed by Nick Hale during 2013-2014 and the team included Anthony Austin, Asgeir Birkisson, Toby Driscoll, Hrothgar, Mohsin Javed, Hadrien Montanelli, Nick Trefethen, Grady Wright, and Kuan Xu. Further information about Chebfun history is available at the Chebfun web site.</p>
<p>This Guide is based on Chebfun Version 5, released in 2014.  Chebfun is available at <a href="http://www.maths.ox.ac.uk/chebfun/">http://www.maths.ox.ac.uk/chebfun/</a>, and an earlier version of the Guide for Version 4 can found there.</p>
<h3 id="12-constructing-simple-chebfuns">1.2  Constructing simple chebfuns</h3>
<p>The <code>chebfun</code> command constructs a chebfun from a specification such as a string or an anonymous function.  If you don't specify an interval, then the default interval $[-1,1]$ is used. For example, the following command makes a chebfun corresponding to $\cos(20x)$ on $[-1,1]$ and plots it.</p>
<pre class="mcode-input">  f = chebfun('cos(20*x)');
  plot(f)</pre>

<p><img src="img/guide1_01.png" alt=""></p>
<p>From this little experiment, you cannot see that <code>f</code> is represented by a polynomial.  One way to see this is to find the length of <code>f</code>:</p>
<pre class="mcode-input">  length(f)</pre>

<pre class="mcode-output">ans =
    59
</pre>

<p>Another is to remove the semicolon that suppresses output:</p>
<pre class="mcode-input">  f</pre>

<pre class="mcode-output">f = 
   chebfun column (1 smooth piece)
       interval       length   endpoint values  
[      -1,       1]       59      0.41     0.41 
Epslevel = 2.183626e-15.  Vscale = 1.
</pre>

<p>These results tell us that <code>f</code> is represented by a polynomial interpolant through 59 Chebyshev points, i.e., a polynomial of degree 58.  These numbers have been determined by an adaptive process.  We can see the data points by plotting <code>f</code>with the <code>'.-'</code> option:</p>
<pre class="mcode-input">  plot(f,'.-')</pre>

<p><img src="img/guide1_02.png" alt=""></p>
<p>The formula for $N+1$ Chebyshev points in $[-1,1]$ is</p>
<p>$$ x(j) = -\cos(j \pi/N), \quad  j = 0:N, $$</p>
<p>and in the figure we can see that the points are clustered accordingly near $1$ and $-1$. Note that in the middle of the grid, there are about 5 points per wavelength, which is evidently what it takes to represent this cosine to 15 digits of accuracy.  For intervals other than $[-1,1]$, appropriate Chebyshev points are obtained by a linear scaling.</p>
<p>The curve between the data points is the polynomial interpolant, which is evaluated by the barycentric formula introduced by Salzer [Berrut &amp; Trefethen 2004, Salzer 1972].  This method of evaluating polynomial interpolants is stable and efficient even if the degree is in the millions [Higham 2004].</p>
<p>What is the integral of $f$ from $-1$ to $1$?  Here it is:</p>
<pre class="mcode-input">  sum(f)</pre>

<pre class="mcode-output">ans =
   0.091294525072763
</pre>

<p>This number was computed by integrating the polynomial (Clenshaw-Curtis quadrature -- see Section 2.1), and it is interesting to compare it to the exact answer from calculus:</p>
<pre class="mcode-input">  exact = sin(20)/10</pre>

<pre class="mcode-output">exact =
   0.091294525072763
</pre>

<p>Here is another example, now with the chebfun defined by an anonymous function instead of a string. In this case the interval is specified as $[0,100]$.</p>
<pre class="mcode-input">  g = chebfun(@(t) besselj(0,t),[0,100]);
  plot(g), ylim([-.5 1])</pre>

<p><img src="img/guide1_03.png" alt=""></p>
<p>The function looks complicated, but it is actually a polynomial of surprisingly small degree:</p>
<pre class="mcode-input">  length(g)</pre>

<pre class="mcode-output">ans =
    89
</pre>

<p>Is it accurate?  Well, here are three random points in $[0,100]$:</p>
<pre class="mcode-input">  format long
  x = 100*rand(3,1)</pre>

<pre class="mcode-output">x =
  91.337585613901936
  63.235924622540949
   9.754040499940952
</pre>

<p>Let's compare the chebfun to the true Bessel function at these points:</p>
<pre class="mcode-input">  exact = besselj(0,x);
  error = g(x) - exact;
  [g(x) exact error]</pre>

<pre class="mcode-output">ans =
  -0.070938332803690  -0.070938332803690  -0.000000000000000
   0.093053890749966   0.093053890749966                   0
  -0.227754955147806  -0.227754955147806  -0.000000000000000
</pre>

<p>If you want to know the first 5 zeros of the Bessel function, here they are:</p>
<pre class="mcode-input">  r = roots(g); r = r(1:5)</pre>

<pre class="mcode-output">r =
   2.404825557695767
   5.520078110286297
   8.653727912911013
  11.791534439014285
  14.930917708487780
</pre>

<p>Notice that we have just done something nontrivial and potentially useful.  How else would you find zeros of the Bessel function so readily? As always with numerical computation, we cannot expect the answers to be exactly correct, but they will usually be very close. In fact, these computed zeros are accurate to close to machine precision:</p>
<pre class="mcode-input">  besselj(0,r)</pre>

<pre class="mcode-output">ans =
   1.0e-14 *
   0.314549201444184
  -0.455365848063064
   0.010653221425832
   0.071369727817872
   0.161773287356131
</pre>

<p>Most often we get a chebfun by operating on other chebfuns. For example, here is a sequence that uses plus, times, divide, and power operations on an initial chebfun <code>x</code> to produce a famous function of Runge:</p>
<pre class="mcode-input">  x = chebfun('x');
  f = 1./(1+25*x.^2);
  length(f)
  clf, plot(f)</pre>

<pre class="mcode-output">ans =
   167
</pre>

<p><img src="img/guide1_04.png" alt=""></p>
<h3 id="13-operations-on-chebfuns">1.3  Operations on chebfuns</h3>
<p>There are more than 200 commands that can be applied to a chebfun.  For a list of many of them you can type <code>methods</code>:</p>
<pre class="mcode-input">  methods chebfun</pre>

<pre class="mcode-output">
Methods for class chebfun:

abs                     domainCheck             not                     
acos                    ellipj                  null                    
acosd                   ellipke                 num2cell                
acosh                   end                     numColumns              
acot                    epslevel                or                      
acotd                   eq                      orth                    
acoth                   erf                     overlap                 
acsc                    erfc                    pde15s                  
acscd                   erfcinv                 pinv                    
acsch                   erfcx                   plot                    
addBreaks               erfinv                  plot3                   
addBreaksAtRoots        exp                     plotData                
airy                    expm1                   plus                    
all                     extractColumns          poly                    
and                     feval                   polyfit                 
angle                   fill                    pow2                    
any                     find                    power                   
arcLength               fix                     prod                    
area                    fliplr                  qr                      
asec                    flipud                  quasi2cheb              
asecd                   floor                   rank                    
asech                   fred                    rdivide                 
asin                    ge                      real                    
asind                   get                     reallog                 
asinh                   getDeltaFunctions       rem                     
assignColumns           getRootsForBreaks       remez                   
atan                    gt                      repmat                  
atan2                   heaviside               residue                 
atan2d                  horzcat                 restrict                
atand                   hscale                  roots                   
atanh                   hypot                   round                   
besselh                 imag                    sec                     
besseli                 innerProduct            secd                    
besselj                 integral                sech                    
besselk                 inv                     semilogx                
bessely                 isdelta                 semilogy                
bvp4c                   isempty                 setPointValues          
bvp5c                   isequal                 sign                    
cat                     isfinite                simplify                
ceil                    isinf                   sin                     
cf                      isnan                   sinc                    
cheb2cell               isreal                  sind                    
cheb2quasi              issing                  sinh                    
chebellipseplot         iszero                  size                    
chebfun                 join                    sound                   
chebpade                jump                    spy                     
chebpoly                ldivide                 sqrt                    
chebpolyplot            le                      std                     
chebtune                legpoly                 subsasgn                
complex                 length                  subspace                
compose                 log                     subsref                 
cond                    log10                   sum                     
conj                    log1p                   surf                    
conv                    log2                    surface                 
cos                     logical                 surfc                   
cosd                    loglog                  svd                     
cosh                    lt                      tan                     
cot                     lu                      tand                    
cotd                    mat2cell                tanh                    
coth                    max                     tidyImpulses            
cov                     mean                    times                   
csc                     merge                   transpose               
cscd                    mesh                    tweakDomain             
csch                    min                     uminus                  
ctranspose              minandmax               unwrap                  
cumprod                 minus                   uplus                   
cumsum                  mldivide                vander                  
cylinder                mod                     var                     
defineInterval          mrdivide                vertcat                 
definePoint             mtimes                  volt                    
diff                    ne                      vscale                  
dirac                   newDomain               waterfall               
disp                    nextpow2                why                     
dispData                norm                    xor                     
display                 normal                  
domain                  normest                 

Static methods:

constructor             mergeDomains            pref                    
detectEdge              ode113                  spline                  
getValuesAtBreakpoints  ode15s                  whichInterval           
interp1                 ode45                   
lagrange                pchip                   

</pre>

<p>To find out what a command does, you can use <code>help</code>.</p>
<pre class="mcode-input">  help chebfun/chebpoly</pre>

<pre class="mcode-output"> CHEBPOLY   Chebyshev polynomial coefficients of a CHEBFUN.
    A = CHEBPOLY(F, N) returns the first N Chebyshev coefficients of F, i.e.,
    the row vector such that F = ... + A(1) T_N(x) + ... + A(N) T_1(x) +
    A(N+1) T_0(x), where T_M(x) denotes the M-th Chebyshev polynomial.

    If F is a smooth CHEBFUN (i.e., with no breakpoints), then CHEBPOLY(F) is
    equivalent to CHEBPOLY(F, LENGTH(F)).

    If F is array-valued with M columns, then A is an MxN matrix.

    C = CHEBPOLY(F, N, 'kind', 2) returns the vector of coefficients for the
    Chebyshev expansion of F in 2nd-kind Chebyshev polynomials F = ... + C(1)
    U_N(x) + ... + C(N) U_1(x) + C(N+1) U_0(x).

    There is also a CHEBPOLY command in the Chebfun trunk directory, which
    computes the CHEBFUN corresponding to the Chebyshev polynomial T_M(x).

  See also LEGPOLY.

</pre>

<p>Most of the commands in the list exist in ordinary Matlab; some exceptions are <code>domain</code>, <code>restrict</code>, <code>chebpoly</code>, <code>define</code>, and <code>remez</code>. We have already seen <code>length</code> and <code>sum</code> in action.  In fact we have already seen <code>subsref</code> too, since that is the Matlab command for (among other things) evaluating arguments in parentheses.  Here is another example of its use:</p>
<pre class="mcode-input">  f(0.5)</pre>

<pre class="mcode-output">ans =
   0.137931034482756
</pre>

<p>Here for comparison is the true result:</p>
<pre class="mcode-input">  1/(1+25/4)</pre>

<pre class="mcode-output">ans =
   0.137931034482759
</pre>

<p>In this Runge function example, we have also implicitly seen <code>times</code>, <code>plus</code>, <code>power</code>, and <code>rdivide</code>, all of which have been overloaded from their usual Matlab uses to apply to chebfuns.</p>
<p>In the next part of this tour we shall explore many of these commands systematically.  First, however, we should see that chebfuns are not restricted to smooth functions.</p>
<h3 id="14-piecewise-smooth-chebfuns">1.4  Piecewise smooth chebfuns</h3>
<p>Many functions of interest are not smooth but piecewise smooth.  In this case a chebfun may consist of a concatenation of smooth pieces, each with its own polynomial representation.  Each of the smooth pieces is called a "fun".  This enhancement of Chebfun was developed initially by Ricardo Pachon during 2006-2007, then also by Rodrigo Platte starting in 2007 [Pachon, Platte and Trefethen 2009]. Essentially funs are the "classic chebfuns" for smooth functions on $[-1,1]$ originally implemented by Zachary Battles in Chebfun Version 1.</p>
<p>Later we shall describe the options in greater detail, but for the moment let us see some examples.  One way to get a piecewise smooth function is directly from the constructor, taking advantage of its capability of automatic edge detection.  For example, in the default "splitting off" mode a function with a jump in its derivative produces a warning message,</p>
<pre class="mcode-input">  f = chebfun('abs(x-.3)');</pre>

<pre class="mcode-output">Warning: Function not resolved using 65537 pts. Have you tried 'splitting on'? 
</pre>

<p>The same function can be successfully captured with splitting on:</p>
<pre class="mcode-input">  f = chebfun('abs(x-.3)','splitting','on');</pre>

<p>The <code>length</code> command reveals that <code>f</code> is defined by four data points, two for each linear interval:</p>
<pre class="mcode-input">  length(f)</pre>

<pre class="mcode-output">ans =
     4
</pre>

<p>We can see the structure of <code>f</code> in more detail by typing <code>f</code> without a semicolon:</p>
<pre class="mcode-input">  f</pre>

<pre class="mcode-output">f = 
   chebfun column (2 smooth pieces)
       interval       length   endpoint values  
[      -1,     0.3]        2       1.3        0 
[     0.3,       1]        2         0      0.7 
Epslevel = 6.492624e-16.  Vscale = 1.300000e+00.  Total length = 4.
</pre>

<p>This output confirms that f consists of two funs, each defined by two points and two corresponding function values. We can see the structure from another angle with <code>disp</code>:</p>
<pre class="mcode-input">  disp(f)</pre>

<pre class="mcode-output">ans =
f = 
   chebfun column (2 smooth pieces)
       interval       length   endpoint values  
[      -1,     0.3]        2       1.3        0 
[     0.3,       1]        2         0      0.7 
Epslevel = 6.492624e-16.  Vscale = 1.300000e+00.  Total length = 4.
</pre>

<p>This output again show that <code>f</code> consists of two funs with breakpoints at $-1$, $1$, and a number very close to $0.3$.  The <code>Vscale</code> field is related to the maximum absolute value of <code>f</code> and <code>Epslevel</code> gives some information (to be discussed later) about its relative accuracy.</p>
<p>Another way to make a piecewise smooth chebfun is to construct it explicitly from various pieces.  For example, the following command specifies three functions $x^2$, $1$, and $4-x$, together with a vector of endpoints indicating that the first function applies on $[-1,1]$, the second on $[1,2]$, and the third on $[2,4]$:</p>
<pre class="mcode-input">  f = chebfun({@(x) x.^2, @(x) 1+0*x, @(x) 4-x},[-1 1 2 4]);
  plot(f)</pre>

<p><img src="img/guide1_05.png" alt=""></p>
<p>We expect <code>f</code> to consist of three pieces of lengths 3, 1, and 2, and this is indeed the case:</p>
<pre class="mcode-input">  f</pre>

<pre class="mcode-output">f = 
   chebfun column (3 smooth pieces)
       interval       length   endpoint values  
[      -1,       1]        3         1        1 
[       1,       2]        1         1        1 
[       2,       4]        2         2        0 
Epslevel = 6.492624e-16.  Vscale = 2.000000e+00.  Total length = 6.
</pre>

<p>Our eyes see pieces, but to Chebfun, <code>f</code> is just another function.  For example, here is its integral.</p>
<pre class="mcode-input">  sum(f)</pre>

<pre class="mcode-output">ans =
   3.666666666666667
</pre>

<p>Here is an algebraic transformation of <code>f</code>, which we plot in another color for variety.</p>
<pre class="mcode-input">  plot(1./(1+f),'r')</pre>

<p><img src="img/guide1_06.png" alt=""></p>
<p>Some Chebfun commands naturally introduce breakpoints in a chebfun. For example, the <code>abs</code> command first finds zeros of a function and introduces breakpoints there.  Here is a chebfun consisting of 6 funs:</p>
<pre class="mcode-input">  f = abs(exp(x).*sin(8*x));
  plot(f)</pre>

<p><img src="img/guide1_07.png" alt=""></p>
<p>And here is an example where breakpoints are introduced by the <code>max</code> command, leading to a chebfun with 13 pieces:</p>
<pre class="mcode-input">  f = sin(20*x);
  g = exp(x-1);
  h = max(f,g);
  plot(h)</pre>

<p><img src="img/guide1_08.png" alt=""></p>
<p>As always, h may look complicated to a human, but to Chebfun it is just a function.  Here are its mean, standard deviation, minimum, and maximum:</p>
<pre class="mcode-input">  mean(h)</pre>

<pre class="mcode-output">ans =
   0.578242020778010
</pre>

<pre class="mcode-input">  std(h)</pre>

<pre class="mcode-output">ans =
   0.280937455806246
</pre>

<pre class="mcode-input">  min(h)</pre>

<pre class="mcode-output">ans =
   0.135335283236613
</pre>

<pre class="mcode-input">  max(h)</pre>

<pre class="mcode-output">ans =
   1.000000000000001
</pre>

<p>A final note about piecewise smooth chebfuns is that the automatic edge detection or "splitting" feature, when it is turned on, may subdivide functions even though they do not have clean point singularities, and this may be desirable or undesirable depending on the application.  For example, considering $\sin(x)$ over $[0,1000]$ with splitting on, we end up with a chebfun with many pieces:</p>
<pre class="mcode-input">  tic, f = chebfun('sin(x)',[0 1000*pi],'splitting','on'); toc
  disp(f)</pre>

<pre class="mcode-output">Elapsed time is 0.796139 seconds.
ans =
f = 
   chebfun column (32 smooth pieces)
       interval       length   endpoint values  
[       0,      98]       88         0    -0.71 
[      98,   2e+02]       88     -0.71        1 
[   2e+02, 2.9e+02]       88         1    -0.71 
[ 2.9e+02, 3.9e+02]       87     -0.71        0 
[ 3.9e+02, 4.9e+02]       87         0     0.71 
[ 4.9e+02, 5.9e+02]       87      0.71       -1 
[ 5.9e+02, 6.9e+02]       86        -1     0.71 
[ 6.9e+02, 7.9e+02]       85      0.71        0 
[ 7.9e+02, 8.8e+02]       86         0    -0.71 
[ 8.8e+02, 9.8e+02]       86     -0.71        1 
[ 9.8e+02, 1.1e+03]       86         1    -0.71 
[ 1.1e+03, 1.2e+03]       86     -0.71        0 
[ 1.2e+03, 1.3e+03]       85         0     0.71 
[ 1.3e+03, 1.4e+03]       86      0.71       -1 
[ 1.4e+03, 1.5e+03]       86        -1     0.71 
[ 1.5e+03, 1.6e+03]       85      0.71        0 
[ 1.6e+03, 1.7e+03]       86         0    -0.71 
[ 1.7e+03, 1.8e+03]       86     -0.71        1 
[ 1.8e+03, 1.9e+03]       86         1    -0.71 
[ 1.9e+03,   2e+03]       85     -0.71        0 
[   2e+03, 2.1e+03]       85         0     0.71 
[ 2.1e+03, 2.2e+03]       86      0.71       -1 
[ 2.2e+03, 2.3e+03]       86        -1     0.71 
[ 2.3e+03, 2.4e+03]       87      0.71        0 
[ 2.4e+03, 2.5e+03]       85         0    -0.71 
[ 2.5e+03, 2.6e+03]       86     -0.71        1 
[ 2.6e+03, 2.7e+03]       84         1    -0.71 
[ 2.7e+03, 2.7e+03]       85     -0.71        0 
[ 2.7e+03, 2.8e+03]       85         0     0.71 
[ 2.8e+03, 2.9e+03]       84      0.71       -1 
[ 2.9e+03,   3e+03]       86        -1     0.71 
[   3e+03, 3.1e+03]       85      0.71        0 
Epslevel = 3.487741e-13.  Vscale = 1.000000e+00.  Total length = 2749.
</pre>

<p>In this case it is more efficient -- and more interesting mathematically -- to omit the splitting and construct one global chebfun:</p>
<pre class="mcode-input">  tic, f2 = chebfun('sin(x)',[0 1000*pi]); toc
  disp(f2)</pre>

<pre class="mcode-output">Elapsed time is 0.035794 seconds.
ans =
f2 = 
   chebfun column (1 smooth piece)
       interval       length   endpoint values  
[       0, 3.1e+03]     1684         0        0 
Epslevel = 3.487915e-13.  Vscale = 9.999862e-01.
</pre>

<h3 id="15-infinite-intervals-and-infinite-function-values">1.5  Infinite intervals and infinite function values</h3>
<p>A major change from Chebfun Version 2 to Version 3 was the generalization of chebfuns to allow certain functions on infinite intervals or which diverge to infinity: the initial credit for these innovations belongs to Nick Hale, Rodrigo Platte, and Mark Richardson. For example, here is a function on the whole real axis,</p>
<pre class="mcode-input">  f = chebfun('exp(-x.^2/16).*(1+.2*cos(10*x))',[-inf,inf]);
  plot(f)</pre>

<p><img src="img/guide1_09.png" alt=""></p>
<p>and here is its integral:</p>
<pre class="mcode-input">  sum(f)</pre>

<pre class="mcode-output">ans =
   Inf
</pre>

<p>Here's the integral of a function on [1,inf]:</p>
<pre class="mcode-input">  sum(chebfun('1./x.^4',[1 inf]))</pre>

<pre class="mcode-output">ans =
   0.333333333378722
</pre>

<p>Notice that several digits of accuracy have been lost here.  Be careful! -- operations involving infinities in Chebfun are not always as accurate and robust as their finite counterparts.</p>
<p>Here is an example of a function that diverges to infinity, which we can capture by including the flag <code>'blowup 2'</code> (try help chebfun for details):</p>
<pre class="mcode-input">  h = chebfun('(1/pi)./sqrt(1-x.^2)','blowup',2);
  plot(h)</pre>

<p><img src="img/guide1_10.png" alt=""></p>
<p>In this case the integral comes out just right:</p>
<pre class="mcode-input">  sum(h)</pre>

<pre class="mcode-output">ans =
   1.000000000000000
</pre>

<p>For more on the treatment of infinities in Chebfun, see Chapter 9.</p>
<h3 id="16-rows-columns-and-quasimatrices">1.6  Rows, columns, and quasimatrices</h3>
<p>Matlab doesn't only deal with column vectors: there are also row vectors and matrices.  The same is true of Chebfun. The chebfuns shown so far have all been in column orientation, which is the default, but one can also take the transpose, compute inner products, and so on:</p>
<pre class="mcode-input">  x = chebfun(@(x) x)</pre>

<pre class="mcode-output">x = 
   chebfun column (1 smooth piece)
       interval       length   endpoint values  
[      -1,       1]        2        -1        1 
Epslevel = 6.492624e-16.  Vscale = 1.
</pre>

<pre class="mcode-input">  x'</pre>

<pre class="mcode-output">ans = 
   chebfun row (1 smooth piece)
       interval       length   endpoint values  
[      -1,       1]        2        -1        1 
Epslevel = 6.492624e-16.  Vscale = 1.
</pre>

<pre class="mcode-input">  x'*x</pre>

<pre class="mcode-output">ans =
   0.666666666666667
</pre>

<p>One can also make matrices whose columns are chebfuns or whose rows are chebfuns, like this:</p>
<pre class="mcode-input">  A = [1 x x.^2]</pre>

<pre class="mcode-output">A = 
   chebfun column1 (1 smooth piece)
       interval       length   endpoint values  
[      -1,       1]        3         1        1 
Epslevel = 2.220446e-15.  Vscale = 1.
   chebfun column2 (1 smooth piece)
       interval       length   endpoint values  
[      -1,       1]        3        -1        1 
Epslevel = 6.492624e-16.  Vscale = 1.
   chebfun column3 (1 smooth piece)
       interval       length   endpoint values  
[      -1,       1]        3         1        1 
Epslevel = 1.298525e-15.  Vscale = 1.
(P.S. I am an array-valued CHEBFUN!)
</pre>

<pre class="mcode-input">  A'*A</pre>

<pre class="mcode-output">ans =
   2.000000000000000   0.000000000000000   0.666666666666667
   0.000000000000000   0.666666666666667  -0.000000000000000
   0.666666666666667  -0.000000000000000   0.400000000000000
</pre>

<p>These are called <em>quasimatrices</em>, and they are discussed in Chapter 6.</p>
<h3 id="17-how-this-guide-is-produced">1.7  How this Guide is produced</h3>
<p>This guide is produced in Matlab using the "publish" command with a style sheet somewhat different from the usual; the output of publish is then processed by markdown. To publish a chapter for yourself, make sure the chebfun guide directory is in your path and then type, for example, <code>open(publish('guide1'))</code>.  The formatting may not be exactly right but it should certainly be legible.</p>
<h3 id="18-references">1.8  References</h3>
<p>[Battles &amp; Trefethen 2004] Z. Battles and L. N. Trefethen, "An extension of Matlab to continuous functions and operators", <em>SIAM Journal on Scientific Computing</em> 25 (2004), 1743-1770.</p>
<p>[Berrut &amp; Trefethen 2005] J.-P. Berrut and L. N. Trefethen, "Barycentric Lagrange interpolation", <em>SIAM Review 46</em> (2004), 501-517.</p>
<p>[Higham 2004] N. J. Higham, "The numerical stability of barycentric Lagrange interpolation", <em>IMA Journal of Numerical Analysis</em> 24 (2004), 547-556.</p>
<p>[Pachon, Platte &amp; Trefethen 2009] R. Pachon, R. B. Platte and L. N. Trefethen, "Piecewise smooth chebfuns", <em>IMA J. Numer. Anal.</em>, 2009.</p>
<p>[Salzer 1972] H. E. Salzer, "Lagrangian interpolation at the Chebyshev points cos(nu pi/n), nu = 0(1)n; some unnoted advantages", <em>Computer Journal</em> 15 (1972), 156-159.</p>
<p>[Trefethen 2007] L. N. Trefethen, "Computing numerically with functions instead of numbers", <em>Mathematics in Computer Science</em> 1 (2007), 9-19.</p>
<p>[Trefethen 2013] L. N. Trefethen, <em>Approximation Theory and Approximation Practice</em>, SIAM, 2013.</p>
            </div>
        </div>

    </div>
    

    <!--     <div class="footer">
        <div style="margin: 5px">
        </div>
        <p>Website powered by <a href="http://urubu.jandecaluwe.com">Urubu</a>.</p>
    </div>

 -->

</div> 


    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/js/bootstrap.min.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/prettify.js?lang=matlab" type="text/javascript"></script>
    <script type="text/javascript" src="/js/config.js"></script>

  </body>
</html>