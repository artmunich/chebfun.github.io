
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>CHEBPREF :: Class for managing Chebfun preferences.</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-01-30"><meta name="DC.source" content="chebpref_DOC.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>CHEBPREF :: Class for managing Chebfun preferences.</h1><pre>  CHEBPREF is a class for managing Chebfun construction-time preferences such
  as the construction tolerance, whether or not to perform breakpoint and
  singularity detection, and the various options that those features require.
  These objects can be supplied to the CHEBFUN constructor (as well as the
  constructors of other classes in the CHEBFUN system), which will interpret
  them and adjust the construction process accordingly.</pre><pre>Available Preferences:</pre><pre>  maxTotalLength             - Maximum total CHEBFUN length.
   [65537]</pre><pre>     Sets the maximum allowed "length" of the constructed CHEBFUN when
     breakpoint detection is disabled, where the notion of length is
     determined by the underlying representation technology (e.g., the number
     of Chebyshev points used for Chebyshev polynomial interpolation).</pre><pre>  enableBreakpointDetection  - Enable/disable breakpoint detection.
    true
   [false]</pre><pre>    If true, breakpoints between FUNS may be introduced where a discontinuity
    in a function or a low-order derivative is detected or if a global
    representation will be too long.  If false, breakpoints will be
    introduced only at points where discontinuities are being created (e.g.,
    by ABS(F) at points where a CHEBFUN F passes through zero).</pre><pre>  breakpointPrefs            - Preferences for breakpoint detection.</pre><pre>     splitMaxLength          - Maximum FUN length.
      [129]</pre><pre>        This is the maximum length of a single FUN (e.g., the number of
        Chebyshev points used for FUNs based on Chebyshev polynomial
        interpolation) allowed by the constructor when breakpoint detection
        is enabled.</pre><pre>     splitMaxTotalLength     - Maximum total CHEBFUN length.
      [6000]</pre><pre>        This is the maximum total length of the CHEBFUN (i.e., the sum of the
        lengths of all the FUNs) allowed by the constructor when breakpoint
        detection is enabled.</pre><pre>  domain                     - Construction domain.
   [-1, 1]</pre><pre>     This sets the default domain that will be used for CHEBFUN and/or FUN
     construction if no domain argument is explicitly passed to the
     constructor.</pre><pre>  enableSingularityDetection - Enable/disable singularity detection.
    true
   [false]</pre><pre>     If true, the constructor will attempt to detect and factor out
     singularities, (e.g., points where a function or its derivatives become
     unbounded). If false, breakpoints will be introduced only at points where
     singularities are being created, (e.g., by SQRT(F) at points where a
     CHEBFUN F passes through zero). See SINGFUN for more information.</pre><pre>  singPrefs                  - Preferences for singularity detection.</pre><pre>     exponentTol             - Tolerance for exponents.
      [1.1*1e-11]</pre><pre>        This is the tolerance up to which the detector will try to resolve
        the singularity exponents.</pre><pre>     maxPoleOrder            - Maximum pole order.
      [20]</pre><pre>        Maximum order of the pole that the singularity detector can find.</pre><pre>     exponents               - Exponents at the end points.
      [[ ]]</pre><pre>        If exponents are supplied by the user from CHEBFUN or FUN levels, the
        default value (empty) is replaced and passed to singfun constructor.
        If no information about the singularity is specified by the user, then
        the singularity detection is triggered to find the exact pole order
        (which is integer) or singularity order (which is fractional) when
        enableSingularityDetection is set TRUE. When exponents are given by
        the user, there is no need to specify the 'singType' field, as any
        information in singType will be ignored by the SINGFUN constructor.
        For a piecewise smooth CHEBFUN, the number of exponents should be
        given in pair with each pair corresponds to the ends of a piece. For
        example,</pre><pre>        dom = [-2 -1 0 1];
        op1 = @(x) sin(x);
        op2 = @(x) 1./(1+x);
        op3 = @(x) x+1;
        op = {op1, op2, op3};
        pref = chebpref();
        pref.singPrefs.exponents = [0 0 -1 0 0 0];
        f = chebfun(op, dom, pref);</pre><pre>        Note that syntax in Chebfun v4 is still supported. So the example
        above can be exercised as below:</pre><pre>        dom = [-2 -1 0 1];
        op1 = @(x) sin(x);
        op2 = @(x) 1./(1+x);
        op3 = @(x) x+1;
        op = {op1, op2, op3};
        f = chebfun(op, dom, 'exps', [0 0 -1 0 0 0]);</pre><pre>        For the cases where the CHEBFUN has more than one piece, if the size
        of the given exponents is 1x2, then the CHEBFUN constructor will take
        them as the exponent for the left endpoint of the first piece and the
        and that for the right endpoint of the last piece. The exponents for
        all other interior endpoints are simply assumed zeros. For example,</pre><pre>        pref = chebpref();
        pref.singPrefs.exponents = [-1 0];
        pref.enableBreakpointDetection = 1;
        f = chebfun(@(x) sin(100*x)./(x+2), [-2 7], pref)</pre><pre>        The equivalent syntax in Chebfun v4 fashion is still valid:</pre><pre>        f = chebfun(@(x) sin(100*x)./(x+2), [-2 7], 'splitting', 'on', ...
            'exps', [-1 0])</pre><pre>     singType                - Type of singularities.
      [{ }]</pre><pre>        The information provided in singType helps the singularity detector to
        determine the order of the singularities more efficiently and save
        some construction time. If the default, i.e. an empty cell, is
        replaced by a user-supplied 2*N cell with entries being any of 'none',
        'pole', 'sing', and 'root' where N is the number of smooth pieces,
        i.e. FUNS, then this cell is passed to the SINGFUN constructor to
        speed up the singularity detection. Here, 'none', 'pole', 'sing', and
        'root' correspond to free of any kind of singularities, integer pole,
        fractional singularity, and root at the end point with order less than
        1, respectively. With the default empty cell, the SINGFUN constructor
        will assume fractional singularities. For instance, setting singType
        to {'pole', 'sing'} tells the singularity detector to search for poles
        at the left endpoint of an interval and arbitrary singularities at the
        right endpoint. For example,</pre><pre>        dom = [-1 1];
        op = @(x) (x - dom(1)).^-0.5.*sin(x);
        pref = chebpref();
        pref.singPrefs.singType = {'sing', 'none'};
        f = chebfun(op, dom, pref);</pre><pre>        Syntactically, chebfun constructor supports automatic singularity
        detection for piecewise smooth CHEBFUN. That is, the users can specify
        a series of the strings described above in pairs with each pair
        corresponds to the endpoints of a subinterval. For example, if one
        want to construct a CHEBFUN definied in [-1 0 1] with poles at -1 and
        1 and fractional singularity on each side of 0, then the series of
        string passed to the CHEBFUN constructor should be {'pole', 'sing',
        'sing', 'pole'}. With these information, the CHEBFUN constructor and
        consequently the SINGFUN will try to find the exact order of the
        singularities. However, the SINGFUN constructor may not succeed for
        most of the cases due to the unsatisfactory performance of the
        current singularity detector.</pre><pre>  scale                      - The vertical scale the constructor should use.
   [0]</pre><pre>     Typically the CHEBFUN constructor will resolve relative to a vertical
     scale determined by it's own function evaluations. However, in some
     situations one would like to the resolve relative to a fixed vertical
     scale. This can be set using this preference.</pre><pre>  tech                       - Representation technology.
   ['chebtech']</pre><pre>     Sets the underlying representation technology used to construct the FUNs.</pre><pre>  techPrefs                  - Preferences for the tech constructor.</pre><pre>     This is a structure of preferences that will be passed to the constructor
     for the underlying representation technology.  See, for example,
     CHEBTECH.TECHPREF for preferences accepted by the default CHEBTECH
     technology.  Additionally, all techs are required to accept the following
     preferences:</pre><pre>     eps                     - Construction tolerance.
      [2^(-52)]</pre><pre>       Specifies the relative tolerance to which the representation should be
       constructed.</pre><pre>     maxLength               - Maximum representation length.
      [65537]</pre><pre>       Maximum length of the underlying representation.</pre><pre>     exactLength             - Exact representation length.
      [NaN]</pre><pre>       Exact length of the underlying representation to be used.  A NaN value
       indicates that the tech is free to choose the length (up to maxLength),
       e.g., as the basis of an adaptive construction procedure.</pre><pre>     extrapolate             - Extrapolate endpoint values.
       true
      [false]</pre><pre>       If true, the tech should avoid direct evaluation of the function at
       the interval endpoints and "extrapolate" the values at those points if
       needed.  It should also extrapolate the values of any points for which
       the function being sampled returns NaN.</pre><pre>     sampleTest              - Test accuracy at arbitrary point.
      [true]
       false</pre><pre>       If true, the tech should check an arbitrary point for accuracy to
       ensure that behavior hasn't been missed, e.g., due to undersampling.</pre><pre>The default values for any of these preferences may be globally overridden
using CHEBPREF.SETDEFAULTS(); see the documentation for that function for
further details.</pre><pre>Constructor inputs:
  P = CHEBPREF() creates a CHEBPREF object with the default values of the
  preferences.  For a list of all available preferences, see above.</pre><pre>  P = CHEBPREF(Q), where Q is a MATLAB structure uses the field/value pairs
  in Q to set the properties of P.  If a field of Q has a name which matches
  a property of P, the value of that property of P is set to the value
  associated to that field in Q.  Any fields of Q that are not properties of
  P are interpreted as preferences for the constructor of the underlying
  representation technology and are placed in P.TECHPREFS.  The exceptions to
  this are the fields BREAKPOINTPREFS, SINGPREFS, and TECHPREFS.  If Q has
  fields with these names, they will be assumed to be MATLAB structures and
  will be "merged" with the structures of default preferences stored in the
  properties of the same names in P using CHEBPREF.MERGEPREFS().</pre><pre>  P = CHEBPREF(Q), where Q is a CHEBPREF, sets P to be a copy of Q.</pre><pre>Notes:
  When building a CHEBPREF from a structure using the second calling syntax
  above, one should take care to ensure that preferences for the underlying
  representation technology are specified once and only once; e.g., do not
  simultaneously set Q.MYPREF = 1 and Q.TECHPREFS.MYPREF = 2.  The value of
  P.TECHPREFS.MYPREF that gets set from P = CHEBPREF(Q) in this circumstance
  is implementation-defined.</pre><pre>Examples:
  Create a CHEBPREF for building a CHEBFUN based on CHEBTECH (default) with
  breakpoint detection, a splitting length of 257 (pieces of polynomial degree
  256, and a custom CHEBTECH refinement function:
     p.enableBreakpointDetection = true;
     p.breakpointPrefs.splitLength = 257;
     p.techPrefs.refinementFunction = @custom;
     pref = chebpref(p);</pre><pre>  Same thing with a slightly shorter syntax:
     p.enableBreakpointDetection = true;
     p.breakpointPrefs.splitLength = 257;
     p.refinementFunction = @custom;
     pref = chebpref(p);</pre><pre>See also SUBSREF, SUBSASGN, MERGEPREFS</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% CHEBPREF :: Class for managing Chebfun preferences.
%    CHEBPREF is a class for managing Chebfun construction-time preferences such
%    as the construction tolerance, whether or not to perform breakpoint and
%    singularity detection, and the various options that those features require.
%    These objects can be supplied to the CHEBFUN constructor (as well as the
%    constructors of other classes in the CHEBFUN system), which will interpret
%    them and adjust the construction process accordingly.
% 
%  Available Preferences:
% 
%    maxTotalLength             - Maximum total CHEBFUN length.
%     [65537]
% 
%       Sets the maximum allowed "length" of the constructed CHEBFUN when
%       breakpoint detection is disabled, where the notion of length is
%       determined by the underlying representation technology (e.g., the number
%       of Chebyshev points used for Chebyshev polynomial interpolation).
% 
%    enableBreakpointDetection  - Enable/disable breakpoint detection.
%      true
%     [false]
% 
%      If true, breakpoints between FUNS may be introduced where a discontinuity
%      in a function or a low-order derivative is detected or if a global
%      representation will be too long.  If false, breakpoints will be
%      introduced only at points where discontinuities are being created (e.g.,
%      by ABS(F) at points where a CHEBFUN F passes through zero).
% 
%    breakpointPrefs            - Preferences for breakpoint detection.
% 
%       splitMaxLength          - Maximum FUN length.
%        [129]
% 
%          This is the maximum length of a single FUN (e.g., the number of
%          Chebyshev points used for FUNs based on Chebyshev polynomial
%          interpolation) allowed by the constructor when breakpoint detection
%          is enabled.
% 
%       splitMaxTotalLength     - Maximum total CHEBFUN length.
%        [6000]
% 
%          This is the maximum total length of the CHEBFUN (i.e., the sum of the
%          lengths of all the FUNs) allowed by the constructor when breakpoint
%          detection is enabled.
% 
%    domain                     - Construction domain.
%     [-1, 1]
% 
%       This sets the default domain that will be used for CHEBFUN and/or FUN
%       construction if no domain argument is explicitly passed to the
%       constructor.
% 
%    enableSingularityDetection - Enable/disable singularity detection.
%      true
%     [false]
% 
%       If true, the constructor will attempt to detect and factor out
%       singularities, (e.g., points where a function or its derivatives become
%       unbounded). If false, breakpoints will be introduced only at points where
%       singularities are being created, (e.g., by SQRT(F) at points where a
%       CHEBFUN F passes through zero). See SINGFUN for more information.
% 
%    singPrefs                  - Preferences for singularity detection.
% 
%       exponentTol             - Tolerance for exponents.
%        [1.1*1e-11]
% 
%          This is the tolerance up to which the detector will try to resolve
%          the singularity exponents.
% 
%       maxPoleOrder            - Maximum pole order.
%        [20]
% 
%          Maximum order of the pole that the singularity detector can find.
% 
%       exponents               - Exponents at the end points.
%        [[ ]]
% 
%          If exponents are supplied by the user from CHEBFUN or FUN levels, the
%          default value (empty) is replaced and passed to singfun constructor.
%          If no information about the singularity is specified by the user, then
%          the singularity detection is triggered to find the exact pole order
%          (which is integer) or singularity order (which is fractional) when
%          enableSingularityDetection is set TRUE. When exponents are given by
%          the user, there is no need to specify the 'singType' field, as any
%          information in singType will be ignored by the SINGFUN constructor.
%          For a piecewise smooth CHEBFUN, the number of exponents should be
%          given in pair with each pair corresponds to the ends of a piece. For
%          example,
% 
%          dom = [-2 -1 0 1];
%          op1 = @(x) sin(x);
%          op2 = @(x) 1./(1+x);
%          op3 = @(x) x+1;
%          op = {op1, op2, op3};
%          pref = chebpref();
%          pref.singPrefs.exponents = [0 0 -1 0 0 0];
%          f = chebfun(op, dom, pref);
% 
%          Note that syntax in Chebfun v4 is still supported. So the example
%          above can be exercised as below:
% 
%          dom = [-2 -1 0 1];
%          op1 = @(x) sin(x);
%          op2 = @(x) 1./(1+x);
%          op3 = @(x) x+1;
%          op = {op1, op2, op3};
%          f = chebfun(op, dom, 'exps', [0 0 -1 0 0 0]);
% 
%          For the cases where the CHEBFUN has more than one piece, if the size
%          of the given exponents is 1x2, then the CHEBFUN constructor will take
%          them as the exponent for the left endpoint of the first piece and the
%          and that for the right endpoint of the last piece. The exponents for
%          all other interior endpoints are simply assumed zeros. For example,
% 
%          pref = chebpref();
%          pref.singPrefs.exponents = [-1 0];
%          pref.enableBreakpointDetection = 1;
%          f = chebfun(@(x) sin(100*x)./(x+2), [-2 7], pref)
% 
%          The equivalent syntax in Chebfun v4 fashion is still valid:
% 
%          f = chebfun(@(x) sin(100*x)./(x+2), [-2 7], 'splitting', 'on', ...
%              'exps', [-1 0])
% 
%       singType                - Type of singularities.
%        [{ }]
% 
%          The information provided in singType helps the singularity detector to
%          determine the order of the singularities more efficiently and save
%          some construction time. If the default, i.e. an empty cell, is
%          replaced by a user-supplied 2*N cell with entries being any of 'none',
%          'pole', 'sing', and 'root' where N is the number of smooth pieces,
%          i.e. FUNS, then this cell is passed to the SINGFUN constructor to
%          speed up the singularity detection. Here, 'none', 'pole', 'sing', and
%          'root' correspond to free of any kind of singularities, integer pole,
%          fractional singularity, and root at the end point with order less than
%          1, respectively. With the default empty cell, the SINGFUN constructor
%          will assume fractional singularities. For instance, setting singType
%          to {'pole', 'sing'} tells the singularity detector to search for poles
%          at the left endpoint of an interval and arbitrary singularities at the
%          right endpoint. For example,
% 
%          dom = [-1 1];
%          op = @(x) (x - dom(1)).^-0.5.*sin(x);
%          pref = chebpref();
%          pref.singPrefs.singType = {'sing', 'none'};
%          f = chebfun(op, dom, pref);
% 
%          Syntactically, chebfun constructor supports automatic singularity
%          detection for piecewise smooth CHEBFUN. That is, the users can specify
%          a series of the strings described above in pairs with each pair
%          corresponds to the endpoints of a subinterval. For example, if one
%          want to construct a CHEBFUN definied in [-1 0 1] with poles at -1 and
%          1 and fractional singularity on each side of 0, then the series of
%          string passed to the CHEBFUN constructor should be {'pole', 'sing',
%          'sing', 'pole'}. With these information, the CHEBFUN constructor and
%          consequently the SINGFUN will try to find the exact order of the
%          singularities. However, the SINGFUN constructor may not succeed for
%          most of the cases due to the unsatisfactory performance of the
%          current singularity detector.
% 
%    scale                      - The vertical scale the constructor should use.
%     [0]
% 
%       Typically the CHEBFUN constructor will resolve relative to a vertical
%       scale determined by it's own function evaluations. However, in some
%       situations one would like to the resolve relative to a fixed vertical
%       scale. This can be set using this preference.
% 
%    tech                       - Representation technology.
%     ['chebtech']
% 
%       Sets the underlying representation technology used to construct the FUNs.
% 
%    techPrefs                  - Preferences for the tech constructor.
% 
%       This is a structure of preferences that will be passed to the constructor
%       for the underlying representation technology.  See, for example,
%       CHEBTECH.TECHPREF for preferences accepted by the default CHEBTECH
%       technology.  Additionally, all techs are required to accept the following
%       preferences:
% 
%       eps                     - Construction tolerance.
%        [2^(-52)]
% 
%         Specifies the relative tolerance to which the representation should be
%         constructed.
% 
%       maxLength               - Maximum representation length.
%        [65537]
% 
%         Maximum length of the underlying representation.
% 
%       exactLength             - Exact representation length.
%        [NaN]
% 
%         Exact length of the underlying representation to be used.  A NaN value
%         indicates that the tech is free to choose the length (up to maxLength),
%         e.g., as the basis of an adaptive construction procedure.
% 
%       extrapolate             - Extrapolate endpoint values.
%         true
%        [false]
% 
%         If true, the tech should avoid direct evaluation of the function at
%         the interval endpoints and "extrapolate" the values at those points if
%         needed.  It should also extrapolate the values of any points for which
%         the function being sampled returns NaN.
% 
%       sampleTest              - Test accuracy at arbitrary point.
%        [true]
%         false
% 
%         If true, the tech should check an arbitrary point for accuracy to
%         ensure that behavior hasn't been missed, e.g., due to undersampling.
% 
%  The default values for any of these preferences may be globally overridden
%  using CHEBPREF.SETDEFAULTS(); see the documentation for that function for
%  further details.
% 
%  Constructor inputs:
%    P = CHEBPREF() creates a CHEBPREF object with the default values of the
%    preferences.  For a list of all available preferences, see above.
% 
%    P = CHEBPREF(Q), where Q is a MATLAB structure uses the field/value pairs
%    in Q to set the properties of P.  If a field of Q has a name which matches
%    a property of P, the value of that property of P is set to the value
%    associated to that field in Q.  Any fields of Q that are not properties of
%    P are interpreted as preferences for the constructor of the underlying
%    representation technology and are placed in P.TECHPREFS.  The exceptions to
%    this are the fields BREAKPOINTPREFS, SINGPREFS, and TECHPREFS.  If Q has
%    fields with these names, they will be assumed to be MATLAB structures and
%    will be "merged" with the structures of default preferences stored in the
%    properties of the same names in P using CHEBPREF.MERGEPREFS().
% 
%    P = CHEBPREF(Q), where Q is a CHEBPREF, sets P to be a copy of Q.
% 
%  Notes:
%    When building a CHEBPREF from a structure using the second calling syntax
%    above, one should take care to ensure that preferences for the underlying
%    representation technology are specified once and only once; e.g., do not
%    simultaneously set Q.MYPREF = 1 and Q.TECHPREFS.MYPREF = 2.  The value of
%    P.TECHPREFS.MYPREF that gets set from P = CHEBPREF(Q) in this circumstance
%    is implementation-defined.
% 
%  Examples:
%    Create a CHEBPREF for building a CHEBFUN based on CHEBTECH (default) with
%    breakpoint detection, a splitting length of 257 (pieces of polynomial degree
%    256, and a custom CHEBTECH refinement function:
%       p.enableBreakpointDetection = true;
%       p.breakpointPrefs.splitLength = 257;
%       p.techPrefs.refinementFunction = @custom;
%       pref = chebpref(p);
% 
%    Same thing with a slightly shorter syntax:
%       p.enableBreakpointDetection = true;
%       p.breakpointPrefs.splitLength = 257;
%       p.refinementFunction = @custom;
%       pref = chebpref(p);
% 
%  See also SUBSREF, SUBSASGN, MERGEPREFS
%
##### SOURCE END #####
--></body></html>