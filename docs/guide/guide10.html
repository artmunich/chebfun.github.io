<!DOCTYPE html>
<html>
  <head>
    <title>10. Nonlinear ODEs and Chebgui &raquo; Chebfun</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <link rel="shortcut icon" href="favicon.ico" /> 

    <!-- Bootstrap -->
    <link href="/css/bootstrap.min.css" rel="stylesheet"><!--  media="screen" -->
    <link href="/css/normalize.min.css" rel="stylesheet"><!--  media="screen" -->
    <link href="/css/chebsite.css" rel="stylesheet"><!--  media="screen" -->
    <link href="/css/tomorrow.css" rel="stylesheet"><!--  media="screen" -->
    <link href="/css/flexslider.css" rel="stylesheet"><!--  media="screen" -->

    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic' rel='stylesheet' type='text/css'>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-4297200-10', 'chebfun.github.io');
  ga('send', 'pageview');
</script>  </head>
  <body>
    <!-- Fixed navbar -->
    <div id='navbar' class="navbar navbar-default navbar-fixed-top">
      <div class="container nav">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button>
          <a id="logo" href="/"><img src='/images/logo.png' /></a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/about">About</a></li>
            <li><a href="/news">News</a></li>
            <li><a href="/download">Download</a></li>
            <li><a href="/docs">Docs</a></li>
            <li><a href="/publications">Publications</a></li>
            <li><a href="/support">Support</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
<div class="page-wrapper">

    <div class='page-header'>
<span class='chapter_number'>10</span>
<h1>Nonlinear ODEs and Chebgui</h1>
<h2>Lloyd N. Trefethen, November 2009, revised February 2011<span>
    
        <a href='/docs/guide/guide9.html'
>previous</a><span class='sep-sm
'>&middot;</span><a href='../guide'>index</a><span class='sep-sm
'>&middot;</span><a href='/docs/guide/guide11.html'
>next</a></span></h2>
</div>

    <div class="container">
<div class="row main">
            <div id='content' class="col-sm-12" role="main">
<p>Chapter 7 described the chebop capability for solving linear ODEs (ordinary differential equations) by a backslash command. We will now describe extensions of chebops to the nonlinear case, as well as other methods for nonlinear ODEs:</p>
<p>Initial-value problems:  ODE45, ODE113, ODE15SBoundary-value problems: BVP4C, BVP5CBoth kinds of problems via chebops:  nonlinear backslash ( = SOLVEBVP)In this chapter we outline the use of these methods; for fuller details, see the "help" documentation and especially the online Chebfun Examples.  The last of the methods listed, nonlinear backslash or SOLVEBVP, represents a "pure Chebfun" approach in which Newton's method is applied on chebfuns, with the necessary derivative operators calculated by Chebfun's built-in capabilities of Automatic Differentiation (AD).  This is the main Chebfun method recommended for solving boundary-value problems.</p>
<p>We use the abbreviations IVP for initial-value problem and BVP for boundary-value problem, as well as BC for boundary condition.</p>
<p>For time-dependent PDEs, see PDE15S, described in Chapter 11.</p>
<h2 id="101-ode45-ode15s-ode113">10.1 ODE45, ODE15S, ODE113</h2>
<p>Matlab has a highly successful suite of ODE IVP solvers introduced originally by Shampine and Reichelt [Shampine &amp; Reichelt 1997]. The codes are called ODE23, ODE45, ODE113, ODE15S, ODE23S, ODE23T, and ODE23TB, and are adapted to various mixes of accuracy requirements and stiffness.</p>
<p>Chebfun includes overloads of ODE45 (for medium accuracy), ODE113 (for high accuracy), and ODE15S (for stiff problems) created by Toby Driscoll and Rodrigo Platte. These codes operate by calling their Matlab counterparts, then converting the result to a chebfun. Thanks to the Chebfun framework of dealing with functions, their use is very natural and simple.</p>
<p>For example, here is a solution of u' = u^2 over [0,1] with initial condition u(0) = 0.95.</p>
<pre class="mcode-input">fun = @(t,u) u.^2;
u = chebfun.ode45(fun, [0, 1], 0.95);
LW = 'linewidth'; lw = 2;
plot(u,LW,lw)</pre>

<p><img src="img/guide10_01.png" class="figure" alt=""></p>
<p>The first argument to ODE45 defines the equation, the second defines the domain for the independent variable, and the third provides the initial condition.  It is the presence of the domain object that directs Matlab to use the chebfun overload of ODE45 rather than the Matlab original.</p>
<p>To find out where the solution takes the value 10, for example, we can write</p>
<pre class="mcode-input">roots(u-10)</pre>

<pre class="mcode-output">ans =
   0.952926047089522
</pre>

<p>As a second example let us consider the linear second-order equation u"=-u, whose solutions are sines and cosines.  We convert this to first-order form by using a vector v with v(1)=u and v(2)=u', and solve the problem again using ode45:</p>
<pre class="mcode-input">fun = @(t, v) [v(2); -v(1)];
v = chebfun.ode45(fun, [0 10*pi], [1 0]);
plot(v,LW,lw)
ylim([-1 1])</pre>

<p><img src="img/guide10_02.png" class="figure" alt=""></p>
<p>Here are the minimum and maximum values attained by u:</p>
<pre class="mcode-input">u = v(:,1); uprime = v(:,2);
minandmax(u)</pre>

<pre class="mcode-output">ans =
  -1.000068010175644
   1.000039406904860
</pre>

<p>Evidently the accuracy is only around five digits.  The reason is that the chebfun ODE45 code uses the same default tolerances as the original ODE45. We can tighten the tolerance using the standard Matlab ODESET command, switching also to ODE113 since it is more efficient for high-accuracy computations:</p>
<pre class="mcode-input">opts = odeset('abstol',3e-14,'reltol',3e-14);
v = chebfun.ode113(fun, [0 10*pi], [1 0], opts);
minandmax(v(:,1))</pre>

<pre class="mcode-output">ans =
  -0.999999999999994
   1.000000000000000
</pre>

<p>As a third example we solve the van der Pol equation for a nonlinear oscillator.  Following the example in Matlab's ODE documentation, we take u" = 1000(1-u^2)u'-u with initial conditions u=2, u'=0.  This is a highly stiff problem whose solution contains very rapid transitions, so we use ode15s with splitting on:</p>
<pre class="mcode-input">opts = odeset('abstol',1e-8,'reltol',1e-8);
fun = @(t,v) [v(2); 1000*(1 - v(1)^2)*v(2) - v(1)];
splitting on
v = chebfun.ode15s(fun, [0 3000], [2 0], opts);
splitting off
u = v(:,1); plot(u,LW,lw)</pre>

<p><img src="img/guide10_03.png" class="figure" alt=""></p>
<p>Here is a pretty good estimate of the period of the oscillator:</p>
<pre class="mcode-input">diff(roots(u))</pre>

<pre class="mcode-output">ans =
   1.0e+02 *
   8.072000511667360
   8.072001250881277
</pre>

<p>Finally here is an illustration of the Lorenz equations:</p>
<pre class="mcode-input">fun = @(t,u) [10*(u(2)-u(1)); 28*u(1)-u(2)-u(1)*u(3); u(1)*u(2)-(8/3)*u(3)];
u = chebfun.ode15s(fun, [0 30], [-5 -7 21], opts);
plot3(u(:,1), u(:,2), u(:,3)), view(-5,9)
axis([-30 30 -50 50 5 45])
xlabel x, ylabel y, zlabel z</pre>

<p><img src="img/guide10_04.png" class="figure" alt=""></p>
<h2 id="102-bvp4c-bvp5c">10.2 BVP4C, BVP5C</h2>
<p>Matlab also has well-established codes BVP4C and BVP5C for solving BVPs, and these too have been overloaded in Chebfun. Again the Chebfun usage becomes somewhat simpler than the original.  In particular, there is no need to call BVPINIT; the initial guess and associated mesh are both determined by an input initial guess u0.</p>
<p>For example, here is the problem labeled "twoode" in the Matlab BVP4C documentation.  The domain is [0,4], the equation is u'' + abs(u) = 0, and the boundary conditions are u(0)=0, u(4)=-2.  We get one solution from the initial condition u=1:</p>
<pre class="mcode-input">twoode = @(x,v) [v(2); -abs(v(1))];
twobc = @(va,vb) [va(1); vb(1)+2];
d = [0,4];
one = chebfun(1, d);
v0 = [one 0*one];
v = bvp4c(twoode, twobc, v0);
u = v(:,1); plot(u,LW,lw)</pre>

<p><img src="img/guide10_05.png" class="figure" alt=""></p>
<p>The initial guess u=-1 gives another valid solution:</p>
<pre class="mcode-input">v0 = [-one 0*one];
v = bvp4c(twoode,twobc,v0);
u = v(:,1); plot(u,LW,lw)</pre>

<p><img src="img/guide10_06.png" class="figure" alt=""></p>
<p>Here is an example with a variable coefficient, a problem due to George Carrier described in Sec. 9.7 of the book by Bender and Orszag [Bender &amp; Orzsag 1978].  On [-1,1], we seek a function u satisfying</p>
<p>ep u" + 2(1-x^2)u + u^2 = 1 ,  u(-1) = u(1) = 0.with ep=0.01.  Here is a solution with BVP5C, just one of many solutions of this problem.</p>
<pre class="mcode-input">ep = 0.01;
ode = @(x,v) [v(2); (1-v(1)^2-2*(1-x^2)*v(1))/ep];
bc = @(va,vb) [va(1); vb(1)];
d = [-1,1];
one = chebfun(1,d);
v0 = [0*one 0*one];
v = bvp5c(ode, bc, v0);
u = v(:,1); plot(u, LW, lw)

%TODO: This no longer seems to give a solution!</pre>

<pre class="mcode-output">Warning: Unable to meet the tolerance without using more than 5000 mesh points.
 The last mesh of 1027 points and the solution are available in the output
 argument.
 The maximum error is 23.2626, while requested accuracy is 0.001. 
</pre>

<p><img src="img/guide10_07.png" class="figure" alt=""></p>
<h2 id="103-automatic-differentiation">10.3 Automatic differentiation</h2>
<p>The options described in the last two sections rely on standard numerical discretizations, whose results are then converted to Chebfun form.  It is natural, however, to want to be able to try solving ODEs fully within the Chebfun context, operating always at the level of functions.  If the ODE is nonlinear, this will lead to Newton iterations for functions, also known as Newton-Kantorovich iterations.  As with any Newton method, this will require a derivative, which in this case becomes a linear operator: an infinite-dimensional Jacobian, or more properly a Frechet derivative.</p>
<p>Chebfun contains features for making such explorations possible.  It is not clear when these approaches can or cannot compute in speed and robustness with BVP4C/BVP5C.  But they offer something entirely new, the possibility of enabling one to explore iterations at the function level. The crucial tool for making all this possible is Chebfun Automatic Differentiation (AD), introduced by Asgeir Birkisson and Toby Driscoll [Birkisson &amp; Driscoll 2011].</p>
<p>To illustrate Chebfun AD, consider the sequence of computations</p>
<pre class="mcode-input">x = chebfun('x', [0 1]);
u = x.^2;
v = exp(x) + u.^3;
w = u + diff(v);</pre>

<p>Suppose we ask, how does one of these variables depend on another one earlier in the sequence?  If the function u is perturbed by an infinitesimal function du, for example, what will the effect be on v?</p>
<p>As mathematicians we can answer this question as follows. The variation takes the form dv/du = 3u^2 = 3x^4.  In other words, dv/du is the linear operator that multiplies a function on [0,1] by 3x^4.</p>
<p>In Chebfun, to compute this operator, we need to decide a variable to act as a basis variable for derivative computations, and seed its derivative. To compute derivatives with respect to u, we convert it to an ADCHEBFUN, and redo the computations:</p>
<pre class="mcode-input">u = adchebfun(u);
v = exp(x) + u.^3;
w = u + diff(v);</pre>

<p>We can now obtain the derivative of v with respect to u by accessing the .jacobian field of v:</p>
<pre class="mcode-input">dvdu = v.jacobian;</pre>

<p>The result dvdu is a linear chebop of the kind discussed in Chapter 7. For example, dvdu*x is 3x^4 times x, or 3x^5:</p>
<pre class="mcode-input">plot(dvdu*x, LW, lw)</pre>

<p><img src="img/guide10_08.png" class="figure" alt=""></p>
<p>TODO: This is no longer supported. If we want dwdv, we'd have to redo the computation, with v seeded as the base variable. But I think the computation of dwdu below is enough to show this point. AB, 2014/06/02.</p>
<p>Notice that dvdu is a multiplication operator, acting on a function just by pointwise multiplication.  (The proper term is "multiplier operator". You can extract the chebfun corresponding to its diagonal part with the command f=diag(dvdu).)  This will not be true of dw/dv, however.  If w = u+diff(v), then w+dw = u+diff(v+dv), so dw/dv must be the differentiation operator with respect to the variable x:</p>
<pre class="mcode-input">% dwdv = diff(w,v); TODO: Remove?</pre>

<p>We can verify for example that dwdv*x is 1:</p>
<pre class="mcode-input">%plot(dwdv*x,LW,lw) TODO: Remove?</pre>

<p>What about dw/du?  Here we must think a little more carefully and compute</p>
<p>dw/du = (partial w/partial u) + (partial w/partial v)<em>(partial
v/partial u)<pre class="mcode">       = I + D</em>3u^2  =  I + D*3x^4 ,</pre>where I is the identity operator and D is the differentiation operator with respect to x.  If we apply dw/du to x, for example, the result will be x + (3x^5)' = x + 15x^4.  The following computation confirms that Chebfun reaches this result automatically.</p>
<pre class="mcode-input">dwdu = w.jacobian;
norm(dwdu*x - (x+15*x.^4))</pre>

<pre class="mcode-output">ans =
     8.422556560155997e-16
</pre>

<p>All these AD calculations are built into Chebfun's diff(f,g) command, making available in principle the linear operator representing the Jacobian (Frechet derivative) of any chebfun with respect to any other chebfun.  We use use the overload "spy" command to see at a glance that the first of our Frechet derivaties is a multiplier operator while the others are non-diagonal:</p>
<pre class="mcode-input">subplot(1,3,2), spy(dvdu), title dvdu
%TODO: Remove? subplot(1,3,2), spy(dwdv), title dwdv
subplot(1,3,2), spy(dwdu), title dwdu</pre>

<p><img src="img/guide10_09.png" class="figure" alt=""></p>
<p>We now look at how AD enables Chebfun users to solve nonlinear ODE problems with backslash, just like the linear ones solved in Chapter 7.</p>
<h2 id="104-nonlinear-backslash-and-solvebvp">10.4 Nonlinear backslash and SOLVEBVP</h2>
<p>In Chapter 7, we realized linear operators as chebops constructed by commands like these:</p>
<pre class="mcode-input">L = chebop(-1, 1);
L.op = @(x,u) 0.0001*diff(u,2) + x.*u;</pre>

<p>We could then solve a BVP:</p>
<pre class="mcode-input">L.lbc = 0;
L.rbc = 1;
u = L\0;
clf, plot(u, 'm', LW, lw)</pre>

<p><img src="img/guide10_10.png" class="figure" alt=""></p>
<p>What's going on in such a calculation is that L is a prescription for constructing matrices of arbitrary dimensions which are spectral approximations to the operator in question.  When backslash is executed, the problem is solved on successively finer grids until convergence is achieved.</p>
<p>The object L we have created is a chebop, with these fields:</p>
<pre class="mcode-input">disp(L)</pre>

<pre class="mcode-output">  chebop with properties:

    domain: [-1 1]
        op: @(x,u)0.0001*diff(u,2)+x.*u
       lbc: @(u)u-BC
       rbc: @(u)u-BC
        bc: []
      init: []
</pre>

<p>Notice that one of the fields is called init, which may hold an initial guess for an iteration if one is specified.  If a guess is not specified, then a zero or linear function is used depending on the boundary conditions. To solve a nonlinear ODE, Chebfun uses a Newton or damped Newton iteration starting at the given initial guess.  Each step of the iteration requires the solution of a linear problem specified by a Jacobian operator (Frechet derivative) evaluated at the current estimated solution.  This is provided by the AD facility, and the linear problem is then solved by chebops.</p>
<p>In Section 7.9 we hand coded our own Newton iteration to solve the nonlinear BVP 0.001u''-u^3 = 0, u(-1) = 1, u(1) = -1. However, since the required Jacobian information is now computed by AD, construction of the Jacobian operator J is taken care of by linearize(L,u), which returns the derivative of the operator J when it is linearized around the function u. Compare the code below to the in Section 7.9.</p>
<pre class="mcode-input">L = chebop(@(x,u) 0.001*diff(u,2) - u.^3);
L.lbc = 1; L.rbc = -1;
u = chebfun('-x');  nrmdu = Inf;
while nrmdu &gt; 1e-10
   r = L*u;
   J = linearize(L,u);
   du = -(J\r);
   u = u + du;  nrmdu = norm(du)
end
clf, plot(u)</pre>

<pre class="mcode-output">nrmdu =
   0.260668532007021
nrmdu =
   0.164126069559970
nrmdu =
   0.098900892365632
nrmdu =
   0.053787171684296
nrmdu =
   0.021518152858755
nrmdu =
   0.003586696693381
nrmdu =
     8.951602490588606e-05
nrmdu =
     5.357404870879134e-08
nrmdu =
     1.896815794357391e-14
</pre>

<p><img src="img/guide10_11.png" class="figure" alt=""></p>
<p>However, it is not necessary to construct such Newton iterations by hand! The code above is a much simplified version of what happens under-the-hood when `nonlinear backslash' is called to solve nonlinear differential equations. A few examples of this are demonstrated below.</p>
<p>Let us reconsider some of the examples of the last three sections.  First in Section 10.1 we had the nonlinear IVP u' = u^2, u(0)=0.95.  This can be solved in chebop formulation like this:</p>
<pre class="mcode-input">N = chebop(0, 1);
N.op = @(x,u) diff(u) - u.^2;
N.lbc = 0.95;
u = N\0;
plot(u,'m',LW,lw)</pre>

<p><img src="img/guide10_12.png" class="figure" alt=""></p>
<p>Next came the linear equation u"=-u.  With chebops, there is no need to reformulate the problem as a first-order system.  There are two boundary conditions at the left, which can be imposed by making N.lbc a function returning an array.</p>
<pre class="mcode-input">N = chebop(0, 10*pi);
N.op = @(x,u) diff(u,2) + u;
N.lbc = @(u) [u-1; diff(u)];
u = N\0;
plot(u, 'm', diff(u), 'c', LW, lw)</pre>

<p><img src="img/guide10_13.png" class="figure" alt=""></p>
<p>The van der Pol problem of Section 10.1 cannot be solved by chebops; the stiffness quickly causes failure of the Newton iteration.</p>
<p>TODO: Verify this is still the case.</p>
<p>Here is the Carrier problem of section 10.2:</p>
<pre class="mcode-input">ep = 0.01;
N = chebop(-1, 1);
N.op = @(x,u) ep*diff(u,2) + 2*(1 - x.^2).*u + u.^2;
N.bc = 'dirichlet';
x = chebfun('x');
N.init = 2*(x.^2 - 1).*(1 - 2./(1 + 20*x.^2));
u = N\1; plot(u, 'm', LW, lw)</pre>

<p><img src="img/guide10_14.png" class="figure" alt=""></p>
<p>We get a different solution from the one we got before! This one is correct too; the Carrier problem has many solutions. If we multiply this solution by sin(x/2) and take the result as a new initial guess, we converge to another new solution:</p>
<pre class="mcode-input">N.init= u.*sin(x/2);
[u, info] = solvebvp(N, 1);
plot(u,'m',LW,lw)
%TODO: This no longer converges?</pre>

<pre class="mcode-output">Warning: Newton iteration failed.
Please try supplying a better initial guess via the .init field
of the chebop. 
</pre>

<p><img src="img/guide10_15.png" class="figure" alt=""></p>
<p>This time, we called the method solvebvp() with two output arguments. The second output is a MATLAB struct, which contains data showing the norms of the updates during the Newton iteration, revealing in this case a troublesome initial phase followed by eventual rapid convergence.</p>
<pre class="mcode-input">semilogy(nrmdu,'.-k',LW,lw), ylim([1e-14,1e2])</pre>

<p><img src="img/guide10_16.png" class="figure" alt=""></p>
<p>Another way to get information about the Newton iteration with nonlinear backlash is by setting</p>
<pre class="mcode-input">cheboppref.setDefaults('plotting','on')</pre>

<p>or</p>
<pre class="mcode-input">cheboppref.setDefaults('display','iter')</pre>

<p>Type help cheboppref for details.  Here we shall not pursue this option and thus return the system to its factory state:</p>
<pre class="mcode-input">cheboppref.setDefaults('plotting','off')
cheboppref.setDefaults('display','none')

% TODO: Do we want to show how to create a cheboppref object, and pass that to
% solvebvp?</pre>

<p>The heading of this section refers to the command SOLVEBVP. When you apply backslash to a nonlinear chebop, it invokes the overloaded Matlab command mldivide; this in turn calls a command SOLVEBVP to do the actual work. By calling SOLVEBVP directly, you can control the computation in ways not accessible through backslash. This situation is just like the relationship in standard Matlab between \ and LINSOLVE. See the help documentation for details.</p>
<h2 id="105-graphical-user-interface-chebgui">10.5 Graphical User Interface: CHEBGUI</h2>
<p>Chebfun includes a GUI (Graphical User Interface) for solving all kinds of ODE, time-dependent PDE, and eigenvalue problems interactively. We will not describe it here, but we encourage the reader to type <code>chebgui</code> and give it a try. Be sure to note the "Demo" menu, which contains dozens of preloaded examples, both scalars and systems. Perhaps most important of all is the "Export to m-file" button, which produces a Chebfun m-file corresponding to whatever problem is loaded into the GUI.  This feature enables one to get going quickly and interactively, then switch to a Chebfun program to adjust the fine points.</p>
<pre class="mcode-input">close all
chebgui</pre>

<pre class="mcode-output">Undefined function or variable 'chebgui'.
Error in guide10 (line 401)
chebgui</pre>

<h2 id="106-references">10.6 References</h2>
<p>[Bender &amp; Orszag 1978] C. M. Bender and S. A. Orszag, Advanced Mathematical Methods for Scientists and Engineers, McGraw-Hill, 1978.</p>
<p>[Birkisson &amp; Driscoll 2011] A. Birkisson and T. A. Driscoll, Automatic Frechet differentiation for the numerical solution of boundary-value problems, ACM Transactions on Mathematical Software, to appear.</p>
<p>[Shampine &amp; Reichelt 1997] L. F. Shampine and M. W. Reichelt, "The Matlab ODE suite", SIAM Journal on Scientific Computing 18 (1997), 1-12.</p></div>
        </div>
    </div>
</div>
    <div class="footer">
        <p>&copy; Copyright 2014 the University of Oxford and the Chebfun Developers.</p>
    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/prettify.js?lang=matlab" type="text/javascript"></script>
    <script type="text/javascript" src="/js/config.js"></script>
    <script type="text/javascript" src="/js/jquery.flexslider-min.js"></script>
  </body>
</html>